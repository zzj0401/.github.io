<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
  <title>用JTest和Enzyme测试 - 日行千里</title>
  <meta charset="UTF-8">
  <meta name="description" content="程序猿日常">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png">
  <meta name="description" content="用JTest和Enzyme测试">
<meta property="og:type" content="article">
<meta property="og:title" content="用JTest和Enzyme测试">
<meta property="og:url" content="http://yoursite.com/2019/08/28/JTest/index.html">
<meta property="og:site_name" content="日行千里">
<meta property="og:description" content="用JTest和Enzyme测试">
<meta property="og:locale" content="zh-tw">
<meta property="og:updated_time" content="2019-08-27T09:02:05.897Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用JTest和Enzyme测试">
<meta name="twitter:description" content="用JTest和Enzyme测试">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="../../../../css/style.css?v=1570602379132">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(http://b-ssl.duitang.com/uploads/item/201708/24/20170824232705_Y2x58.jpeg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="../../../../index.html" title="shuo" class="mdui-btn mdui-btn-icon"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2003571102,4002116936&amp;fm=26&amp;gp=0.jpg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="../../../../index.html" title="shuo">
            <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2003571102,4002116936&amp;fm=26&amp;gp=0.jpg" alt="shuo">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>14</div>
        <div><span>Tags</span>0</div>
        <div><span>Categories</span>0</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="../../../../index.html" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="../../../../about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="../../../../PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Social</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/zzj0401/zzj0401.github.io" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Archive</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 shuo
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
        <img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3097266091,3774088458&fm=26&gp=0.jpg">
        
        <h1>用JTest和Enzyme测试</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月28日</a>
    <a><i class="nexmoefont icon-areachart"></i>2.3k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 11 分钟</a>
    
    
  </div>
  <article>
    <h1 id="用JTest和Enzyme测试"><a href="#用JTest和Enzyme测试" class="headerlink" title="用JTest和Enzyme测试"></a>用JTest和Enzyme测试</h1><a id="more"></a>

<h2 id="JTest"><a href="#JTest" class="headerlink" title="JTest"></a>JTest</h2><p>1.安装(npm install –save-dev jest）后在package.json中配置：</p>
<pre><code>{
  &quot;scripts&quot;:

   {&quot;test&quot;:&quot;jest&quot;}

}</code></pre><p>2.一些常用的语法</p>
<p>普通适配器：</p>
<pre><code>test (&#39;two plus two is four&#39;,()=&gt;{

  expect(2+2).toBe(4);

})</code></pre><p>对象：</p>
<pre><code>test(&#39;object assignment&#39;,()=&gt;{

   const daata={one:1}

   data[&#39;two&#39;]=2;

   expect(data).toEqual({

     one:1,

     two:2

   })

})</code></pre><p>递归：</p>
<pre><code>test(&#39;adding positive numbers is not zero&#39;, () =&gt; {
 for (let a = 1; a &lt; 10; a++) {
  for (let b = 1; b &lt; 10; b++) {
    expect(a + b).not.toBe(0);
  }
 }
})</code></pre><p>数字比较：</p>
<p> （&gt;3):   toBeGreaterThan(3)</p>
<p>   (&gt;=3):  toBeGreaterOrEqualThan(3)</p>
<p>​    (&lt;3):    toBeLessThan(3)</p>
<p>比较浮点数相等：</p>
<pre><code>test(&#39;两个浮点数相加&#39;,()=&gt;{

  const value=0.1+0.2；

   expect(value).toBeCloseTo(0.3)

})</code></pre><p>正则表达式：toMatch</p>
<p>包含（数组，对象）toContain</p>
<p>错误异常：toThrow===》</p>
<p>.toThorw可能够让我们测试被测试方法是否按照预期抛出异常，但是在使用时需要注意的是：我们必须使用一个函数将将被测试的函数做一个包装，正如上面getIntArrayWrapFn所做的那样，否则会因为函数抛出导致该断言失败。</p>
<pre><code>import functions  from &#39;../src/functions&#39;;

test(&#39;getIntArray(3.3)应该抛出错误&#39;, () =&gt; {
  function getIntArrayWrapFn() {
    functions.getIntArray(3.3);
  }
  expect(getIntArrayWrapFn).toThrow(&#39;&quot;getIntArray&quot;只接受整数类型的参数&#39;);
})</code></pre><p>toEqual匹配器会递归的检查对象所有属性和属性值是否相等，所以如果要进行应用类型的比较时，请使用.toEqual匹配器而不是.toBe。</p>
<p>.toHaveLength可以很方便的用来测试字符串和数组类型的长度是否满足预期。</p>
<p>3.回调</p>
<p>使用单个参数调用done,jest会等done回调函数执行结束后结束测试</p>
<pre><code>test(&#39;the data is peanut better&#39;,done=&gt;{

  function callback(data){

    expect(data).toBe(&#39;peanut butter&#39;);

    done();

  }

fetchData(callback)

})</code></pre><p>expect.assertions(1)，它能确保在异步的测试用例中，有一个断言会在回调函数中被执行。这在进行异步代码的测试中十分有效。</p>
<p>使用promise执行异步(一定不要忘记把 promise 作为返回值)</p>
<pre><code>test(&#39;the fetch fails with an error&#39;,()=&gt;{

  return fetchData().then(data=&gt;{

  expevt(data).toBe(&#39;peanut butter&#39;)

  })

})</code></pre><p>4.对一些重复性工作的处理</p>
<pre><code>beforeEach(()=&gt;{

 initializeCityDatabase();

})

afterEach((=&gt;{

  clearCityDatabase();

}))</code></pre><p>一次性设置</p>
<pre><code>beforeAll(()=&gt;{

  return initializeCityDatabase();

})

afterAll(() =&gt; {
  return clearCityDatabase();
});</code></pre><p>作用域：</p>
<pre><code>describe(&#39;matching cities to foods&#39;,()=&gt;{

  beforeEach(() =&gt; {
    return initializeFoodDatabase();
   });
  test(&#39;Vienna &lt;3 sausage&#39;, () =&gt; {
    expect(
    isValidCityFoodPair(&#39;Vienna&#39;, &#39;WienerSchnitzel&#39;)
     ).toBe(true);
   });
   test(&#39;San Juan &lt;3 plantains&#39;, () =&gt; {
    expect(
    isValidCityFoodPair(&#39;San Juan&#39;,&#39;Mofongo&#39;
    ).toBe(true);
   });

})</code></pre><p>Jest 会在所有真正的测试开始之前执行测试文件里所有的 describe 处理程序（handlers）。 这是在 before* 和 after* 处理程序里面 （而不是在 describe 块中）进行准备工作和整理工作的另一个原因。 当 describe 块运行完后,，默认情况下，Jest 会按照 test 出现的顺序</p>
<p>仅运行一个测试：</p>
<pre><code>test.only(&#39;this will be the only test that runs&#39;,()=&gt;{

  expect(true).toBe(false);

})</code></pre><p>5.mock：代码之间的连接：擦除函数的实现，捕获函数的调用等</p>
<p>.mock它保存了关于此函数如何被调用、调用时的返回值的信息。 </p>
<p>Mock函数提供的以下三种特性，在我们写测试代码时十分有用：</p>
<p>捕获函数调用情况<br>设置函数返回值<br>改变函数的内部实现</p>
<p>=====================</p>
<p>(1).jest.fn:创建Mock函数，如果没有定义函数内部的实现，则返回undefine</p>
<p>toBeCalled:被调用</p>
<p>toBeCalledTimes(1):被调用一次</p>
<p>toHaveBeenCalledWith(1,2,3):传入的参数1,2,3</p>
<p>(2).jest.fn()创建的函数设置返回值，定义内部实现</p>
<pre><code>test(&quot;测试jest.fn()返回固定值&quot;,()=&gt;{

 let mockFn=jest.fn().mockReturnValue(&#39;default&#39;);

  expect(mockFn().toBe(&#39;default&#39;);)

  })

test(&#39;测试jest.fn()内部实现&#39;,()=&gt;{

  let mockFn=jest.fn((num1,num2)=&gt;{

  return num1*num2

})

expect(mockFn(10,10)).toBe(100)

})</code></pre><p>利用async实现异步</p>
<pre><code>//fetch.js
import axios from &#39;axios&#39;;

export default {
  async fetchPostsList(callback) {
    return axios.get(&#39;https://jsonplaceholder.typicode.com/posts&#39;).then(res =&gt; {
      return callback(res.data);
    })
  }
}</code></pre><pre><code>import fetch from &#39;../src/fetch.js&#39;

test(&#39;fetchPostsList中的回调函数应该能够被调用&#39;, async () =&gt; {
  expect.assertions(1);
  let mockFn = jest.fn();
  await fetch.fetchPostsList(mockFn);

  // 断言mockFn被调用
  expect(mockFn).toBeCalled();
})</code></pre><p>（3）jest.mock():在jest中如果想捕获函数的调用情况，则该函数必须被mock或者spy！</p>
<pre><code>import fetch from &#39;./fetch&#39;;

export default {
  async getPostList() {
    return fetch.fetchPostsList(data =&gt; {
      console.log(&#39;fetchPostsList be called!&#39;);
      // do something
    });
  }
}</code></pre><pre><code>// functions.test.js

import events from &#39;../src/events&#39;;
import fetch from &#39;../src/fetch&#39;;

jest.mock(&#39;../src/fetch.js&#39;);

test(&#39;mock 整个 fetch.js模块&#39;, async () =&gt; {
  expect.assertions(2);
  await events.getPostList();
  expect(fetch.fetchPostsList).toHaveBeenCalled();
  expect(fetch.fetchPostsList).toHaveBeenCalledTimes(1);
});</code></pre><p>jest.spyOn()方法同样创建一个mock函数，但是该mock函数不仅能够捕获函数的调用情况，还可以正常的执行被spy的函数。实际上，jest.spyOn()是jest.fn()的语法糖，它创建了一个和被spy的函数具有相同内部代码的mock函数。</p>
<p>(4)mock的其他方法：改变mock函数=》mockImplementationOnce</p>
<p>const myMockFn=jest</p>
<pre><code>.fn(()=&gt;&#39;default&#39;)

.mockImplementationOnce(()=&gt;&#39;first call&#39;)

.mockImplementationOnce(()=&gt;&#39;second call&#39;)

console.log(myMockFn(),myMockFn(),myMockFn(),myMockFn())</code></pre><p>打印结果：</p>
<p>=====&gt;’first call’,’second call’,’default’,’default’</p>
<p>==========================================</p>
<p><strong>const</strong> myObj = {<br>myMethod: jest.fn().mockReturnThis(),<br>};<br>// is the same as<br><strong>const</strong> otherObj = {<br>myMethod: jest.fn(<strong>function</strong>() {<br><strong>return</strong> <strong>this</strong>;<br>}),<br>};</p>
<p>=============================================</p>
<p>mock名称：jest.mockName(‘add42’)</p>
<p>// 这个 mock 函数至少被调用一次<br>expect(mockFunc).toBeCalled();</p>
<p>// 这个 mock 函数至少被调用一次，而且传入了特定参数<br>expect(mockFunc).toBeCalledWith(arg1, arg2);</p>
<p>// 这个 mock 函数的最后一次调用传入了特定参数<br>expect(mockFunc).lastCalledWith(arg1, arg2);</p>
<p>// 所有的 mock 的调用和名称都被写入了快照<br>expect(mockFunc).toMatchSnapshot();</p>
<p>6.快照</p>
<p>（1）安装依赖：npm install react-test-render –save-dev</p>
<p>​           使用： </p>
<p>​           </p>
<pre><code>import React from &#39;react&#39;

​           import renderer from &#39;react-test-renderer&#39;

​           import Alink from &#39;../components/Link.react&#39;;

​           it(&#39;正确的渲染&#39;,()=&gt;{

​            const tree=renderer

​                   .create(&lt;ALink page=&quot;https://www.gowhich.com&quot;&gt;Gowhich&lt;/ALink&gt;)

​                    .toJSON();

​                  expect(tree).toMatchSnapshot();

​           })</code></pre><p>​          重新生成快照</p>
<p>​         npx jest 目录 –notify –watchman=false –updateSnapshot</p>
<p>​          数据更新：</p>
<pre><code>      it(&#39;检查匹配器并测试通过&#39;, () =&gt; {</code></pre><pre><code>  const user = {
    createAt: new Date(),
    id: Math.floor(Math.random() * 20),
    name: &#39;Durban&#39;,
  };

 expect(user).toMatchSnapshot({

   createAt:expect.any(Date),

    id:expect.any(Number)

  })

})</code></pre><p>7.定时期</p>
<pre><code>const timerGame =require(&#39;../lib/timerGame&#39;);

jest.useFakeTimers();

test(&#39;等待1秒钟后结束游戏&#39;()=&gt;{

  timerGame();

  expect(setTimeout).toHaveBeenCalledTimes(1);

  expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function),1000)

})</code></pre><p>运行所有计时器</p>
<pre><code>const timerGame=require(&#39;../lib/timerGame&#39;);

jest.useFakeTimers();

test(&#39;1秒钟后调用回调callback&#39;,()=&gt;{

const callback=jest.fn();

timerGame(callback);

// 在这个时间点上，callback回调函数还没有被调用

expect(callback).not.toBeCalled();

 // 所有timers被执行

jest.runAllTimers();

  // 现在我们的callback回调函数被调用

expect(callback).toBeCalled();

expect(callback).toHaveBeenCalledTimes(1);



})          </code></pre><p>运行待定时间器：</p>
<p>runOnlyPendingTimers()</p>
<p>按时间提前计时器</p>
<p>advanceTimersByTime(1000)</p>
<p>添加覆盖率和颜色：”test”:”jest –colors –coverage”(package.json)</p>
<h2 id="Enzyme"><a href="#Enzyme" class="headerlink" title="Enzyme"></a>Enzyme</h2><p>1.三种测试方法：</p>
<p>shallow:返回组件的浅渲染（当前组件，虚拟dom）</p>
<p>mount:将组件加载成真实DOM，会渲染当前组件和子组件</p>
<p>render:渲染结果为普通的html结构</p>
<p>2.API：</p>
<p>.get(index):返回指定位置的子组件的Dom节点</p>
<p>.at(index):返回指定位置的子组件</p>
<p>.first():返回第一个组件</p>
<p>.last():返回最后一个组件</p>
<p>.type():返回当前组件的类型</p>
<p>.text():返回当前组件的文本内容</p>
<p>.html():返回当前组件的HTML代码形式</p>
<p>.props():返回根组件的所有属性</p>
<p>.props(key):返回根组件的指定属性</p>
<p>.state([key]):返回根组件的状态</p>
<p>.setState(nextState):设置根组件的状态</p>
<p>.setProps(nextProps)：设置根组件的属性</p>
<p>eg:expect (wrapper.find(‘input’).prop(‘value’)).toBe(‘default value’)</p>
<p>3.模拟Props</p>
<pre><code>import {shallow} from  &#39;enzyme&#39;

import React from &#39;react&#39;

import {OrderManage}from &#39;../../components/purchaser/OrderManege&#39;

const setup={{...props}}=&gt;{

  const wrapper=shallow(&lt;OrderManage{...props}/&gt;);

  return{

     props,

     wrapper,

   };

  };

  describe(&#39;OrderManage&#39;,()=&gt;{

    it(&#39;role is operator&#39;,()=&gt;{

    const {wrapper}=setup({

    role:&#39;operator&#39;,

    isFetching:true,

    fetchOrdersByStatuses:()=&gt;{},//直接设为空函数

    getData:jest.fn(),//Jest提供的mock函数

    })；

const params={

   node:{

   id:2,

   },

 };

expect(wrapper.instance().handlePageChange(1));

expect(wrapper.instance().OrderManagementLink(params));

expect(wrapper.find(&#39;.loader&#39;)).toHaveLength(1);

expect(wrapper.find(&#39;.order-simpleGrid&#39;)).toHaveLength(0);

expext(wrapper.type()).toEqual(&#39;div&#39;)

  })

})

//instance:获取组件的内部成员对象</code></pre><p>组件中的方法测试：</p>
<p>//组件</p>
<pre><code>export class Card extends React.Component{

  constructor(props){

    super(props)

    this.cardType=&#39;initCard&#39;

   }

 changeCardType(cardType){

    this.cardType=cardType

 }

}</code></pre><p>//test</p>
<pre><code>it(&#39;changeCardType&#39;,()=&gt;{

  let component =shallow(&lt;Card/&gt;)

  expect(component.instance().cardType).toBe(&#39;initCard&#39;)

  component.instance().changeCardType(&#39;testCard&#39;)

  expect(component.instance().cardType).toBe(&#39;testCard&#39;)

})</code></pre><p>4.模拟事件测试</p>
<pre><code>&lt;input value={value} onChange={e=&gt;this.handleChange(e)}/&gt;

//test

it(&#39;can save value and cancel&#39;,()=&gt;

  const value=&#39;edit&#39;

  const {wrapper,props}=setup{{

  editable:true

 }}

wrapper.find(&#39;input&#39;).simulate(&#39;change&#39;,{target:{value}});

wrapper.setProps({status:&#39;save&#39;});

expect(props.onChange).toBeCalledWith(value)

})</code></pre><p>==========================</p>
<p>wrapper.find(‘button’).simulate(‘click’)；</p>
<p>wrapper.find(‘input’).simulate(‘keyup’)；</p>
<p>expect(props.onClick).toBeCalled()；// onClick方法被调用</p>
<p>expect(props.onClick).not.toBeCalled() // onClick方法没被调用</p>
<pre><code>import { shallow } from &#39;enzyme&#39;;
import sinon from &#39;sinon&#39;;
import Foo from &#39;./Foo&#39;;

describe(&#39;&lt;MyComponent /&gt;&#39;, () =&gt; {
  it(&#39;renders three &lt;Foo /&gt; components&#39;, () =&gt; {
    const wrapper = shallow(&lt;MyComponent /&gt;);
    expect(wrapper.find(Foo)).to.have.lengthOf(3);
  });

  it(&#39;renders an `.icon-star`&#39;, () =&gt; {
    const wrapper = shallow(&lt;MyComponent /&gt;);
    expect(wrapper.find(&#39;.icon-star&#39;)).to.have.lengthOf(1);
  });

  it(&#39;renders children when passed in&#39;, () =&gt; {
    const wrapper = shallow((
      &lt;MyComponent&gt;
        &lt;div className=&quot;unique&quot; /&gt;
      &lt;/MyComponent&gt;
    ));
    expect(wrapper.contains(&lt;div className=&quot;unique&quot; /&gt;)).to.equal(true);
  });

  it(&#39;simulates click events&#39;, () =&gt; {
    const onButtonClick = sinon.spy();
    const wrapper = shallow(&lt;Foo onButtonClick={onButtonClick} /&gt;);
    wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);
    expect(onButtonClick).to.have.property(&#39;callCount&#39;, 1);
  });
});</code></pre>
  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>Author：</strong>shuo<br>
<strong>Link：</strong><a href="http://yoursite.com/2019/08/28/JTest/" title="http://yoursite.com/2019/08/28/JTest/" target="_blank" rel="noopener">http://yoursite.com/2019/08/28/JTest/</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="../../../../js/app.js?v=1570602379138"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>

  





</body>

</html>
