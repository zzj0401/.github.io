<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
  <title>Es6语法 - 日行千里</title>
  <meta charset="UTF-8">
  <meta name="description" content="程序猿日常">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png">
  <meta name="description" content="es6语法">
<meta property="og:type" content="article">
<meta property="og:title" content="Es6语法">
<meta property="og:url" content="http://yoursite.com/2019/10/14/20191012-es6语法/index.html">
<meta property="og:site_name" content="日行千里">
<meta property="og:description" content="es6语法">
<meta property="og:locale" content="zh-tw">
<meta property="og:updated_time" content="2019-10-17T09:18:24.583Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Es6语法">
<meta name="twitter:description" content="es6语法">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="../../../../css/style.css?v=1571994655093">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(http://b-ssl.duitang.com/uploads/item/201708/24/20170824232705_Y2x58.jpeg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="../../../../index.html" title="shuo" class="mdui-btn mdui-btn-icon"><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2003571102,4002116936&amp;fm=26&amp;gp=0.jpg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="../../../../index.html" title="shuo">
            <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2003571102,4002116936&amp;fm=26&amp;gp=0.jpg" alt="shuo">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>Articles</span>18</div>
        <div><span>Tags</span>0</div>
        <div><span>Categories</span>0</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="../../../../index.html" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="../../../../about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="../../../../PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Social</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/20238211" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/zzj0401/zzj0401.github.io" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">Archive</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/08/">八月 2019</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 shuo
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
    <div class="nexmoe-post-cover"> 
        
        <img src="http://img5.imgtn.bdimg.com/it/u=3283695009,2324565468&fm=26&gp=0.jpg">
        
        <h1>Es6语法</h1>
    </div>
  <div class="nexmoe-post-meta">
    <a><i class="nexmoefont icon-calendar-fill"></i>2019年10月14日</a>
    <a><i class="nexmoefont icon-areachart"></i>5.7k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 30 分钟</a>
    
    
  </div>
  <article>
    <h1 id="es6语法"><a href="#es6语法" class="headerlink" title="es6语法"></a>es6语法</h1><a id="more"></a>

<h2 id="1-解构赋值"><a href="#1-解构赋值" class="headerlink" title="1.解构赋值"></a>1.解构赋值</h2><p>数组：</p>
<pre><code>let a,b,c,cc,rest;
[a,b]=[1,2]
//a:1,b:2
[a,b,...rest]=[1,2,3,4,5,6]
//a:1,b:2,rest:[3,4,5,6]
[a,b,c=3]=[1,2]
//a:1,b:2,c:3
[a,b,cc]=[1,2]
//a:1,b:2,cc:undefind
let aa=1;
let bb=2;
[aa.bb]=[bb,aa]
//aa:2,bb:1
function f(){
return [1,2]
}
let fa,fb;
[fa, fb]=f();
//fa:1.fb:2
</code></pre><p>对象：</p>
<pre><code>let a,b;
({a,b}={a:1,b:2})
//a:1,b:2
let o={p:42,q:true};
let{p,q}=o
//p:42,q:true
let {aa=10,bb=5}={aa:3}
//aa:3,bb:5
let metaData={
title:&#39;abc&#39;,
test:[{
title:&#39;test&#39;,
desc:&#39;description&#39;
}]
}
let {title:estitle,test:[{title:cntitle}]}=metaData
//estitle:abc
//cntitle:test</code></pre><h2 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2.正则表达式"></a>2.正则表达式</h2><pre><code>//es5的正则表达式
let regex=new RegExp(&#39;xyz&#39;,&#39;i&#39;)
//或
let regex=new RegExp(/xyz/i)
//es6:
let regex3=new RegExp(/xyz/ig,&#39;i&#39;)
//regex3.flags:i
//flags:获取正则表达式的修饰符</code></pre><h3 id="关于正则表达式的修饰符"><a href="#关于正则表达式的修饰符" class="headerlink" title="关于正则表达式的修饰符"></a>关于正则表达式的修饰符</h3><p>i：不区分大小写</p>
<p>g：全局匹配，第二次匹配是从上一次匹配的结果之后开始寻找，可以忽略中间的任何字符直至找到符合的</p>
<p>s：默认的圆点 . 是匹配除换行符 \n 之外的任何单字符，加上s之后, . 中包含换行符</p>
<p>y(es6)：全局匹配，第二次匹配是从上一次匹配的结果之后开始寻找，不可以忽略中间的任何字符，必须是下一个也符合才可以被匹配，否则返回null</p>
<pre><code>//g与y的区别的例子
let s=&quot;bbb_bb_b&quot;
let a1=/b+/g
let a2=/b+/y
console.log(&#39;one&#39;,a1.exec(s),a2.exec(s));
//one [&#39;bbb&#39;,index:0,input:&#39;bbb_bb_b&#39;]  [&#39;bbb&#39;,index:0,input:&#39;bbb_bb_b&#39;]
console.log(&#39;two&#39;,a1.exec(s),a2.exec(s));
//two [&#39;bb&#39;,index:4,input:&#39;bbb_bb_b&#39;] null
console.log(a1.sticky,a2.sticky)
//false true
//sticky:此属性用来检测正则表达式是否使用y修饰符。</code></pre><p>u：unicode编码</p>
<pre><code>console.log(&#39;u-1&#39;,/^\uD83D/.test(&#39;\uD83D\uDC2A&#39;))
/true,&#39;\uD83D\uDC2A&#39;视为两个字符
console.log(&#39;u-2&#39;,/^\uD83D/u.test(&#39;\uD83D\uDC2A&#39;))
//false，&#39;\uD83D\uDC2A&#39;视为一个字符
console.log(/\u{61}/.test(&#39;a&#39;))  //false
console.log(/\u{61}/u.test(&#39;a&#39;))  //true a的unicode编码是61</code></pre><p>.:匹配任意字符，但超过两个字节就没法识别(以及换行符，回车符，行/段分隔符)</p>
<pre><code>console.log(&#39;\u{20887}&#39;) //𠢇
console.log(&#39;u&#39;,/^.$/.test(&#39;𠢇&#39;)) //false
console.log(&#39;u-2&#39;,/^.$/u.test(&#39;𠢇&#39;)) //true 加u可以判断有大于两个自己的字符
console.log(&#39;test&#39;,/𠢇{2}/.test(&#39;𠢇𠢇&#39;)) //false
console.log(&#39;test-2&#39;,/𠢇{2}/u.test(&#39;𠢇𠢇&#39;)) //true</code></pre><h3 id="字符串的处理"><a href="#字符串的处理" class="headerlink" title="字符串的处理"></a>字符串的处理</h3><p>charCodeAt：取两个字节，codePointAt：取四个字节</p>
<pre><code>console.log(&#39;a&#39;,&#39;\u0061&#39;) // a,a
console.log(&#39;s&#39;,&#39;\u20887&#39;)
//a7，因为超出了一个字符,当成两个字符：2088和7
console.log(&#39;\u{20887}&#39;) //𠢇
let s=&quot;𠢇&quot;
console.log(&#39;length&#39;,s.length)
//length 2
console.log(&#39;0&#39;,s.charAt(0))//取字符，打印出来是乱码
console.log(&#39;1&#39;,s.charAt(1)) //打印出来是乱码
console.log(&#39;at0&#39;,s.charCodeAt(0)) //取码值 55362
console.log(&#39;at0&#39;,s.charCodeAt(1)) //取码值 56455
let s1=&quot;𠢇a&quot;;
console.log(&#39;code0&#39;,s1.codePointAt(0))
//取第一个字符’𠢇‘的编码
//code0 133255
console.log(&#39;code1&#39;,s1.codePointAt(0).toString(16))
//以16进制的形式取第一个字符’𠢇‘的编码
//code1 20887
console.log(&#39;code2&#39;,s1.codePointAt(1)) 
//若没有4个字节，就取后面两个字节
//code2 56445，’𠢇’的后两个字节
console.log(&#39;code3&#39;,s1.codePointAt(2)) 
//97 a的编码</code></pre><p>es5不能处理大于2个字节的字符，会乱码，但es6可以输出</p>
<pre><code>console.log(String.fromCharCode(&#39;0x20bb7&#39;));
//乱码
console.log(String.fromCodePoint(&#39;0x20bb7&#39;));
//输出正常
</code></pre><p>es5和es6的遍历</p>
<pre><code>let str=&#39;\u{20bb7}abc&#39;
//es5的遍历
for(let i=0;i&lt;str.length;i++){
console.log(&#39;es5&#39;,str[i])
//前2个乱码，后面正常输出
}
//es6的遍历，正常处理大于2个字节的字符
for(let code of str){
console.log(&#39;es6&#39;,code)
}
//打印结果：
//es6 𠮷
// es6 a
// es6 b
// es6 c</code></pre><p>判断是否有某个字符：</p>
<pre><code>let str=&#39;string&#39;
console.log(&#39;includes&#39;,str.includes(&#39;r&#39;)) //true
console.log(&#39;start&#39;,str.startsWith(&#39;str&#39;)) //true
console.log(&#39;start&#39;,str.endsWith(&#39;ing&#39;)) //true</code></pre><p>重复：</p>
<pre><code>console.log(str.repeat(2))
//repeat(重复次数)</code></pre><p>模板字符串：把数据和结果拼成带模板的字符串</p>
<pre><code>let m=`i am ${name},${info}`</code></pre><p>es7的草案，需要打补丁才能使用</p>
<pre><code>npm i babel-polyfill --save-dev</code></pre><pre><code>import &#39;babel-polyfill&#39;
console.log(&#39;1&#39;,padStart(2,&#39;0&#39;))
//向前补充长度，就是‘1’得有两个字节，如果没有，就用‘0&#39;补充
//01
console.log(&#39;1&#39;,padEnd(2,&#39;0&#39;))
//向后补充长度
//10</code></pre><p>标签模板：过滤信息，只留下模板，防止攻击，可以用于处理多语言转化</p>
<pre><code>let user={
name:&#39;list&#39;,
info:&#39;hello&#39;
}
console.log(abc`i am ${user.name},${user.info}`)
// i am ,,,listhello
function abc(s,v1,v2){
console.log(s,v1,v2)
return s+v1+v2
}
// [&quot;i am &quot;, &quot;,&quot;, &quot;&quot;, raw: Array(3)] &quot;list&quot; &quot;hello&quot;</code></pre><p>String.raw：把斜杆进行转义，即在斜杆之前再加斜杆</p>
<pre><code>console.log(String.raw`Hi\n${1+2}`)
//Hi\n3
console.log(Hi\n${1+2}`)
//Hi
//3</code></pre><h2 id="3-数值扩展"><a href="#3-数值扩展" class="headerlink" title="3.数值扩展"></a>3.数值扩展</h2><p>二进制以0b开头(b可以大小写)，八进制 0o(o可以大小写)</p>
<pre><code>console.log(0b101011) //43
console.log(0o767) //503</code></pre><p>Number.isFinite ：是否有尽</p>
<pre><code>console.log(&#39;NaN&#39;,Number.isFinite(NaN))//false</code></pre><p>isInteger：判断是否是整数</p>
<pre><code>console.log(&#39;25.0&#39;,Number.isInteger(25.0)) //true</code></pre><p>es6的数在-2的53次方到2的53次方之间</p>
<pre><code>console.log(Number.MAX_SAFE_INTEGER)
//常量，表示数的上限，下限：MIN_SAFE_INTEGER
//判断是否在-2的53次方到2的53次方之间
Number.isSafeInteger(数字)</code></pre><p>Math.trunc()：判断带小数的数字的整数部分并返回</p>
<pre><code>console.log(Math.trunc(4.1)) //4
console.log(Math.trunc(4.9)) //4</code></pre><p>Math.sign()：判断是否是正数，负数，0</p>
<pre><code>console.log(&#39;-5&#39;,Math.sign(-5)) //-1
console.log(&#39;0&#39;,Math.sign(0)) //0
console.log(&#39;5&#39;,Math.sign(5)) //1
console.log(&#39;50&#39;,Math.sign(&#39;50&#39;)) //1
//把字符转化为数字
console.log(&#39;foo&#39;,Math.sign(&#39;foo&#39;)) //NaN
//字符串：NAN</code></pre><p>Math.cbrt()：立方根的计算</p>
<pre><code>Math.cbrt(-1) //-1
Math.cbrt(8) //2</code></pre><p>其他还有三角函数和对数的用法</p>
<h2 id="4-数组扩展"><a href="#4-数组扩展" class="headerlink" title="4.数组扩展"></a>4.数组扩展</h2><pre><code>let arr=Array.of(3,4,7,8,11)
console.log(&#39;arr&#39;,arr) // [3,4,7,8,11]
let empty=Array.of()
console.log(&#39;empty&#39;,empty) // []</code></pre><p>把伪数组或集合转化为数组</p>
<pre><code>&lt;p&gt;葫芦娃&lt;/p&gt;
&lt;p&gt;哪吒&lt;/p&gt;
&lt;p&gt;十万个冷笑话&lt;/p&gt;</code></pre><pre><code>let p=document.querySelectorAll(&#39;p&#39;)
//p标签的集合
let pArr=Array.from(p)
//集合变成数组
pArr.forEach(function(item){
console.log(item.textContent);
//拿到item的文本
//打印结果：
//葫芦娃 哪吒 十万个冷笑话
})
console.log(Array.from([1,3,5],function(item){
return item+2
}))
//[3, 5, 7]</code></pre><p>数组内容替换</p>
<pre><code>console.log(&#39;fill-7&#39;,[1,&#39;a&#39;,undefined].fill(7))
//[7,7,7],数组全部替换成7
console.log(&#39;fill-7&#39;,[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;].fill(7，1，3))
//表示替换成7，起始位置是1，结束位置是3
//[&#39;a&#39;,7,7]</code></pre><p>返回所有的下标或值的集合</p>
<pre><code>for(let index of [&#39;1&#39;,&#39;c&#39;,&#39;ks&#39;].keys()){
console.log(&#39;ky&#39;,indexs)
}
//ky 0
//ky 1
//ky 2
for(let value of [&#39;1&#39;,&#39;c&#39;,&#39;ks&#39;].values()){
//取对应的值
console.log(&#39;value：&#39;,value)
}
//value：1
//value：c
//value：ks
//以上方法存在兼容性问题
for(let[indx,value] of [&#39;1&#39;,&#39;c&#39;,&#39;ks&#39;].entries()){
//不存在兼容性问题
console.log(&#39;value：&#39;,index,value)
}
//value：0 1
//value：1 c
//value：2 ks</code></pre><p>将当前数组内部指定位置的成员复制到指定位置上</p>
<pre><code>console.log([1,2,3,4,5].copyWithin(0,3,4))
// [4, 2, 3, 4, 5]
//第一个参数：从哪个位置开始替换
//第二个参数：从哪个位置读取数据
//第三个参数：从哪个位置截至
//这个代码的意思是：从下标0开始，到下标4之前截至，即[1,2,3,4]
//替换成下标3的值即4，替换值只有一个，结果是将下标0替换成下标3</code></pre><p>查找一个元素是不是在一个数组中</p>
<pre><code>console.log([1,2,3,4,5,6].find(function(item){
return item&gt;3
}))
//4,只会找第一个满足条件的成员
console.log([1,2,3,4,5,6].findIndex(function(item){
return item&gt;3
}))
//3,返回第一个满足条件的成员的下标
//解决NAN的状况
console.log(&#39;number&#39;,[1,2,NAN].includes(1));
//true
console.log(&#39;number&#39;,[1,2,NAN].includes(NAN));
//true</code></pre><h2 id="5-函数扩展"><a href="#5-函数扩展" class="headerlink" title="5.函数扩展"></a>5.函数扩展</h2><p>函数默认值</p>
<pre><code>

function test(x,y=&#39;so&#39;){
console.log(x,y)
}
test(&#39;ok&#39;)
//ok so
//有默认值的变量后面不能有没有默认值的变量
//如test(x,y=&#39;so&#39;，c)会报错
let a=&#39;test&#39;
function test2(a,b=a){
console.log(a,b)
}
test2(&#39;kid&#39;)
//kid kid
test2()
//undefind undefind
function test3(c,b=a){
console.log(c,b)
}
test(&#39;kid&#39;)
//kid test</code></pre><p>将所有参数转化为数组</p>
<pre><code>function test3(...args){

for(let v of arg){

console.log(v)

}

test3(1,2,3,4,&#39;a&#39;)</code></pre><p>将数组转化成离散的值</p>
<pre><code>console.log(...[1,2,4])
//1 2 4
console.log(a,...[1,2,4])
//a 1 2 4</code></pre><p>尾调用：函数的最后一句话是不是函数</p>
<pre><code>function tail(x){
console.log(&#39;tail&#39;,x)
}
function fx(x){
return tail(x)
}
fx(1)//1</code></pre><h2 id="6-对象扩展"><a href="#6-对象扩展" class="headerlink" title="6.对象扩展"></a>6.对象扩展</h2><p>表示法</p>
<pre><code>let o=1;
let k=2;
let a=&#39;b&#39;；
let es6={
o,
k,
[a]: &#39;c&#39;,//属性表达式，等价与：b:&#39;c&#39;
hello(){
console.log(&#39;hi&#39;)
}//对象中的方法
}</code></pre><p>拷贝</p>
<pre><code>console.log(&#39;字符串&#39;，Object.is(&#39;abc&#39;,&#39;abc&#39;))//等价与&#39;abc&#39;===&#39;abc&#39;,true
console.log(&#39;字符串&#39;，Object.is([],[]))//数组是引用，值相等，但地址不同,false
console.log(Object.assign({a:&#39;a&#39;},{b:&#39;b&#39;}))
//{a:&#39;a&#39;,b:&#39;b&#39;}
//第一级属性深拷贝，以后级别属性浅拷贝 ，将后面参数的属性复制到第一个
//只有自身对象的属性，不可枚举的属性
//遍历输出
for(let [key,value] of Object.entries({k:1,u:9})){
console.log(key,value)
}</code></pre><p>补充：深浅拷贝</p>
<p>浅拷贝：将原对象或原数组的引用直接赋给对象，新数组/对象只是原对象的一个引用</p>
<p>深拷贝：创建一个新的对象和数组，将原对象的各项属性的值（数组的所有元素）拷贝过来，是值不是引用</p>
<p>深拷贝的方法：</p>
<p>（1）slice:从已有的数组中截取一部分元素片段组成的新数组，不改变原来的数组！</p>
<p>（2）concat() 方法用于连接两个或多个数组。( 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。)</p>
<p><a href="https://blog.csdn.net/qq_39207948/article/details/81067482" target="_blank" rel="noopener">https://blog.csdn.net/qq_39207948/article/details/81067482</a></p>
<p>针对Object.assign的例子:</p>
<pre><code>//例子1：
let s={name:{asd:&#39;123&#39;}}
let d=Object.assign({},s)
d.name.asd=&#39;123456&#39;
console.log(d,s)
//{name:{asd: &quot;123456789&quot;}}
//{name:{asd: &quot;123456789&quot;}}



//例子2
let o={name:{asd:&#39;123&#39;}}
let p=Object.assign({},s)
p.name = &#39;123456789&#39;
console.log(p, o)
//{name: &quot;123456789&quot;}
//{name: {asd: &quot;123&quot;}}</code></pre><h2 id="7-Symbol"><a href="#7-Symbol" class="headerlink" title="7.Symbol"></a>7.Symbol</h2><p>提供独一无二的值</p>
<pre><code>//声明
let a1=Symbol()
//若想要2个Symbol里面的值相等
let a2=Symbol.for(&#39;a2&#39;)
let a3=Symbol.for(&#39;a2&#39;)
console.log(a2===a3)//true</code></pre><p>取值：</p>
<pre><code>let a1=Symbol.for(&#39;abc&#39;)
let obj={
[a1]: &#39;123&#39;,
&#39;abc&#39;:345,
&#39;c&#39;:456
}
//采用Symbol的对象属性是无法通过Object.entries等常规方法取得他的值的
//取值
Object.getOwnPropertySymbols(obj).forEach(function(item){
console.log(obj[item])
})
//123
//getOwnPropertySymbols(obj):返回的是一个数组</code></pre><p>Reflect.ownKeys(obj):返回的结果包含了symbol的key值作为属性和非symbol的属性的数组</p>
<h2 id="8-数据结构"><a href="#8-数据结构" class="headerlink" title="8.数据结构"></a>8.数据结构</h2><p>set：array，集合中的元素是不能重复的</p>
<p>map：object，key可以是任何形式的值</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>定义：</p>
<pre><code>let list=new Set();
list.add(5)
list.add(7)
console.log(list) // Set(2) {5, 7}
console.log(list.size)  //长度  2
let arr=[1,2,3,4,5]
let list2=new Set(arr)
//长度：5
//元素必须是唯一的
ist.add(7)
console.log(&#39;list&#39;,list)//Set(2) {5, 7}
//相同的不会报错，只会不添加
//用于去重</code></pre><p>去重（不会做数据类型的转化）：</p>
<pre><code>let arr=[1,2,3,1,2]
let list2=new Set(arr)
console.log(list2)</code></pre><p>方法：</p>
<pre><code>let arr=[&#39;add&#39;,&#39;delete&#39;,&#39;clear&#39;,&#39;has&#39;]
let list=new Set(arr)
console.log(&#39;has&#39;,list.has(&#39;add&#39;))//true
list.delete(&#39;add&#39;)
list.clear()
for(let key of list.keys()){
console.log(&#39;keys&#39;,key)
//add delete clear has
}
for(let key of list.values())){
console.log(&#39;keys&#39;,key)
//add delete clear has
}
for(let key of list)){
console.log(&#39;keys&#39;,key)
//add delete clear has
}
for(let [key,value] of list.entries())){
console.log(&#39;keys&#39;,key,value)
}
//add add
//delete delete
//clear clear
//has has
list.forEach(function(item){
console.log(item)})</code></pre><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>与Set的区别：支持的数据类型不一样，WeakSet元素只能是对象，是弱引用，不会检测是不是被垃圾回收站引用了</p>
<p>/没有clear的方法</p>
<p>没有size</p>
<p>不能遍历</p>
<pre><code>let weakList=new WeakSet();
let arg={
weakSet.add(arg)
}</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><pre><code>{

let map=new Map();
let arr=[&#39;123&#39;]
//添加元素
map.set(arr,456)
console.log(map,map.get(arr))
//Map(1) {Array(1)=&gt;456}
//key:[&#39;123&#39;]
//value:456
//456
let map=new Map([[&#39;a&#39;,123],[&#39;b&#39;,456]])
//a=&gt;123
//b=&gt;456
//长度：map.size
//删除：map.delete(&#39;a&#39;)
//清除：map.clear()

}</code></pre><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><pre><code>let weakmap=new WeakMap()</code></pre><h3 id="Map、set与Array的对比"><a href="#Map、set与Array的对比" class="headerlink" title="Map、set与Array的对比"></a>Map、set与Array的对比</h3><pre><code>let map=new Map();
let set=new Set();
let array=[];

//增

map.set(&#39;t&#39;,1)
set.add({t:1});
array.push({t:1}

//查

let map_exist=map.has(&#39;t&#39;)//true
let set_exist=set.has({t:1})//false,若要为true，值则必须被引用过
let array_exist=array.find(item=&gt;item.t)//返回当前对象

//改

map.set(&#39;t&#39;,2)
set.forEach(item=&gt;item.t?item.t=2:&#39;&#39;)
array.forEach(item=&gt;item.t?item.t=2:&#39;&#39;)

//删

map.delete(&#39;t&#39;)
set.forEach(item=&gt;item.t?set.delete(item):&#39;&#39;)
let index=array.findIndex(item=&gt;item.t)
array.splice(index,1)

)</code></pre><h3 id="Map、set与Object的对比"><a href="#Map、set与Object的对比" class="headerlink" title="Map、set与Object的对比"></a>Map、set与Object的对比</h3><pre><code>//先定义item，使得值有被引用
let item={t:1}
let map=new Map();
let set=new Set()
let obj={};

//增

map.set(&#39;t&#39;,1)
set.add(item)
obj[&#39;t&#39;]=1

//查

let map_exist=map.has(&#39;t&#39;)//true
console.log(set.has(item))
console.log(&#39;t&#39; in obj)

//返回当前对象

//改

map.set(&#39;t&#39;,2)
item.t=2//因为set存的是引用
obj[&#39;t&#39;]=2
array.forEach(item=&gt;item.t?item.t=2:&#39;&#39;)

//删

map.delete(&#39;t&#39;)
set.delete(item)
delete obj[&#39;t&#39;]

}</code></pre><h2 id="9-Proxy和Reflect"><a href="#9-Proxy和Reflect" class="headerlink" title="9.Proxy和Reflect"></a>9.Proxy和Reflect</h2><p>proxy:代理，用户与最真实的对象</p>
<p>reflect:反射</p>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><pre><code>let obj={
time:&#39;2017-01&#39;,
name:&#39;net&#39;,
_r:123
}
//作为一个原始的对象来存储最真实的数据
let monitor=new Proxy(obj,{
//代理的方法
//拦截对象属性的读取
get(target,key){
return target[key].replace(&#39;2017&#39;,&#39;2018&#39;)
//把所有2017替换成2018
}
set(target.key,value){
//只允许修改name的属性
if(key===&#39;name&#39;){
return target[key]=value
}else{
return target[key]
}
}
//拦截key in object操作

has(target,key){
//自暴露name属性，其他的不暴露
if(key===&#39;name&#39;){
return target[key]
}else{
return false
}
}
//拦截delete
deleteProperty(target,key){
//只允许删除下划线开头的
if(key.indexOf(&#39;_&#39;)&gt;-1){
delete target(key);
return true
}else{
return target[key]
}
}
//拦截Object.getOwnOropertySymbols,Object.getOwnOropertyNames
OwnKeys(target){
//保护time属性
return Objet.keys(target).filter(item=&gt;item!=&#39;time&#39;)
}
})
//monitor是映射这个对象，用户访问的是monitor,最终将用户的操作通过Proxy传给原对象obj
console.log(monitor.time) //2018-01
monitor.time=&#39;2010&#39;;
console.log(monitor.time) //2018-01
monitor.name=&#39;zhumeng&#39;;
console.log(monitor.name) //zhumeng
console.log(&#39;name&#39; in monitor)//true
console.log(&#39;time&#39; in monitor)//false
console.log(delete monitor.time)//2018-01
//console.log(delete monitor._r)//true
console.log(Object.keys(monitor))//[&#39;name&#39;,_r]//time属性被保护起来了</code></pre><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><pre><code>let obj={
time:&#39;2017-01&#39;,
name:&#39;net&#39;,
_r:123
}
console.log(Reflect.get(obj,&#39;time&#39;))
Reflect.set(obj,&#39;name&#39;,&#39;zhumeng&#39;)
Reflect.has(obj,&#39;name&#39;)</code></pre><p>应用—校验模块</p>
<pre><code>function vaildator(target,vaildator){
return new Proxy(target,{
_vaildator:vaildator,
set(target,key,value,proxy){
if(target.hasOwnProperty(key)){
let va=this._validator[key]
if(!!va(value)){
return Reflect.set(target,key,value,propx)
}else{
throw Error(`不能设置${key}到${value}`)
}
}else{
throw Error(`${key}不存在`)
}
}
}
)
}

//过滤条件

const  personValidators={
name(val){
return typeof val===&#39;string&#39;
}
age(val){
return typeof val===&#39;number&#39;&amp;&amp;val&gt;18
}
}
class Person{
constructor(name,age){
this.name=name;
this.age=age
return validator(this，personValidators)
}
}
const person=new Person(&#39;lilei&#39;,30)
console.info(person)
person.name=48//报错，不能设置${key}到${value}
}</code></pre><h2 id="10-类"><a href="#10-类" class="headerlink" title="10.类"></a>10.类</h2><pre><code>class Person{//定义了一个名字为Person的类
    constructor(name,age=9){//constructor是一个构造方法，用来接收参数,age=9:子类重写name属性值
        this.name = name;//this代表的是实例对象
        this.age=age;
    }
    super(props)//supe使得子组件可以修改从父组件继承的参数（props)，子类向父类修改 super一定放第一行
    say(){//这是一个类的方法，注意千万不要加上function
        return &quot;我的名字叫&quot; + this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;;
    }
}
var obj=new Person(&quot;laotie&quot;,88);
console.log(obj.say());//我的名字叫laotie今年88岁了
//1.在类中声明方法的时候，千万不要给该方法加上function关键字
//2.方法之间不要用逗号分隔，否则会报错</code></pre><pre><code>console.log(typeof Person);//function
console.log(Person===Person.prototype.constructor);//true</code></pre><p>实际上类的所有方法都定义在类的prototype属性上。代码证明下：</p>
<pre><code>Person.prototype.say=function(){//定义与类中相同名字的方法。成功实现了覆盖！
    return &quot;我是来证明的，你叫&quot; + this.name+&quot;今年&quot;+this.age+&quot;岁了&quot;;
}
var obj=new Person(&quot;laotie&quot;,88);
console.log(obj.say());//我是来证明的，你叫laotie今年88岁了</code></pre><p>还可以通过Object.assign()方法来为对象动态添加方法</p>
<pre><code>Object.assign(Person.protype,{
getName:function(){
 return this.name;
},
 getAge:function(){
        return this.age;
    }
})
var obj=new Person(&#39;laotie&#39;,88)
console.log(obj.getName());//laotie
console.log(obj.getAge());//88</code></pre><p>类的静态方法：</p>
<pre><code>class Parent{
construct(name=&#39;xiamu&#39;){
this.name=name
}
// 静态方法:通过类去调用，而不是实例
static tel(){
console.log(&#39;tell&#39;)
}
}
Parent.tell()
Parent.type=&#39;test&#39;//定义静态属性
console.log(&#39;静态属性&#39;,Parent.type) // 静态属性 test
let v_parent = new Parent();
    console.log(v_parent); // {name: &quot;xiaxaioxian&quot;}  没有tell方法和type属性</code></pre><h2 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11.Promise"></a>11.Promise</h2><p>原生异步:</p>
<pre><code>let ajax=function(callback){
console.log(执行)
setTimeout(function(){
callback&amp;&amp;callback.call()
},1000)
};
ajax(function(){
console.log(&#39;timeout1&#39;)
})
//先输出执行再输出timeout1</code></pre><p>promise的基本调用:</p>
<pre><code>let ajax=function(){
console.log(&#39;执行2&#39;)；
return new Promise(function(resolve,reject){
setTimeout(function(){
resolve()
},1000)
})
}

ajax().then(
//resolve
function(){
console.log(&#39;promise&#39;,&#39;timeout2&#39;)
},function(){
//reject
return &#39;error&#39;
}
)
//ajax返回一个promise实例，then表示执行下一步
//执行2 promise timeout2</code></pre><pre><code>let ajax=function(){
console.log(&#39;执行3&#39;)；
return new Promise(function(resolve,reject){
setTimeout(function(){
resolve()
},1000)
})
}
ajax()
.then(function(){
//再返回一个promise函数。继续下一步
return new Promise(
function(resolve,reject){
setTimeout(function(){
resolve()
},2000)
}
)
}).then(function(){
console.log(&#39;timeout3&#39;)
})
//执行3     promise timeout2 timeout 3
</code></pre><p>捕获异常：</p>
<pre><code>let ajax=function(num){
console.log(&#39;执行4&#39;)
return new Promise(function(resolve,reject){
if(num&gt;5){
resolve()}
else{
throw new Error(&#39;出错了&#39;)
}
})
}
ajax(6).then(function(){
console.log(&#39;log&#39;,6)
}).catch(function(err){
console.log(&#39;catch&#39;,err)
})
//log 6 
ajax(3).then(function(){
console.log(&#39;log&#39;,6)
}).catch(function(err){
console.log(&#39;catch&#39;,err)
})
//catch Error</code></pre><p>Promise.all：把多个Promise实例当成一个Promise实例，当所有Promise实例都完成后整个promise才算完成，才调用then</p>
<p>应用场景例子：所有图加载完后再显示在页面上</p>
<pre><code>function loadImg(src){
return new Promise((resolve,reject)=&gt;{
let img=doucument.createElement(&#39;img&#39;);
img.src=src;
img.onload=function(){
resolve(img)
}
img.onerror=function(err){
reject(err);
}
})}
//添加到页面
function showImgs(imgs){
imgs.forEach(function(img){
document.body.appendChild(img);
})
}

Promise.all({
loadImg(&#39;http://.......png&#39;),//加载当前图片
loadImg(&#39;http://.......png&#39;),
loadImg(&#39;http://.......png&#39;),
}).then(showImgs)</code></pre><p>Promise.race：多个实例中有一个率先改变，则这个Promise改变，其他的不再响应</p>
<p>应用场景例子：仅有1个图显示在页面上，谁先加载完谁先显示</p>
<pre><code>function loadImg(src){
return new Promise((resolve,reject)=&gt;{
let img=doucument.createElement(&#39;img&#39;);
img.src=src;
img.onload=function(){
resolve(img)
}
img.onerror=function(err){
reject(err);
}
})}

function showImgs(img){
let p=documnet.createElement(&#39;p&#39;);
p.appendChild(img)
document.body.appendChild(p)
}

Promise.race({
loadImg(&#39;http://.......png&#39;),//加载当前图片
loadImg(&#39;http://.......png&#39;),
loadImg(&#39;http://.......png&#39;),
}).then(showImgs)</code></pre><h2 id="12-Iterator和for…of"><a href="#12-Iterator和for…of" class="headerlink" title="12.Iterator和for…of"></a>12.Iterator和for…of</h2><pre><code>//数组内部的Iterator的接口已经定义好了
let arr=[&#39;hello&#39;,&#39;world&#39;]
//调用Iterator接口
let map=arr[Symbol.iterator]();
//返回一个对象
console.log(map.next())
console.log(map.next())
console.log(map.next())
//object{value:&#39;hello&#39;,done:false}
//object{value:&#39;world&#39;,done:false}
//object{value:undefind,done:true}
//done:有下一步状态为false,没有为true</code></pre><p>object  自定义使用Iterator接口</p>
<pre><code>let obj={
start:[1,3,2],
end:[7,9,8],
[Symbol.iterator](){
let sele=this;
let index=0;
let arr=self.start.concat(self.end);
let len=arr.length;
return{
next(){
//写遍历的过程
if(index&lt;len){
return{
value:arr[index++],
done:false
}
}else{
return{
value:arr[index++],
done:true
}
}
}
}
}
}
for(let key of obj){
console.log(key)
}
//先遍历start再遍历end
//132798</code></pre><h2 id="13-Generator"><a href="#13-Generator" class="headerlink" title="13.Generator"></a>13.Generator</h2><p>异步编程的总解决方案</p>
<pre><code>let tell=function* (){
yield &#39;a&#39;;
yield &#39;b&#39;;
return &#39;c&#39;
};
let k=tell();
console.log(k.next())
console.log(k.next())
console.log(k.next())
console.log(k.next())
//object{value:&#39;a&#39;,done:false}
//object{value:&#39;b&#39;,done:false}
//object{value:&#39;c&#39;,done:false}
//object{value:undefind,done:true}
//调用next，执行一个yield</code></pre><pre><code> let obj={};
  obj[Symbol.iterator]=function* (){
    yield 1;
    yield 2;
    yield 3;
  }
 for(let value of obj){
    console.log(&#39;value&#39;,value);
  }
// value 1
// value 2
// value 3</code></pre><p>循环调用</p>
<pre><code> let state=function* (){
    while(1){
      yield &#39;A&#39;;
      yield &#39;B&#39;;
      yield &#39;C&#39;;
    }
  }
  let status=state();
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  //ABCAB</code></pre><p>语法糖async写法</p>
<pre><code> let state=async function (){
    while(1){
      await &#39;A&#39;;
      await &#39;B&#39;;
      await &#39;C&#39;;
    }
  }
  let status=state();
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());
  console.log(status.next());</code></pre><h2 id="14-Decorators"><a href="#14-Decorators" class="headerlink" title="14.Decorators"></a>14.Decorators</h2><p>装饰器：是个修改类行为的函数</p>
<pre><code>//只读装饰器定义
let readonly=function(target,name,descriptor){
    descriptor.writable=false;
    return descriptor
  };
class Test{
   @readonly
   time(){
     return &#39;2017-03-11&#39;
   }
 }

let test=new Test();

  // test.time=function(){
  //   console.log(&#39;reset time&#39;);
  // };
  //无法写，报错，因为装饰器的作用

console.log(test.time());</code></pre><pre><code>let typename=function(target,name,descriptor){
    target.myname=&#39;hello&#39;;
  }

  @typename
  class Test{

  }

  console.log(&#39;类修饰符&#39;,Test.myname);//hello</code></pre><p>第三方库修饰器的js库：core-decorators; npm install core-decorators</p>
<h2 id="15-模块化"><a href="#15-模块化" class="headerlink" title="15.模块化"></a>15.模块化</h2><pre><code>//导出一个变量
export let myName=&quot;laowang&quot;;
//导出多个变量
export {
    myName,
    myAge,
    myfn
}
//引入的时候用{}包裹，名字须相同
import {myfn,myAge,myName} from &quot;./test.js&quot;;
//若不想暴露模块当中的变量名字，可以通过as来进行操作:
export {
    myName as name,
    myAge as age,
    myfn as fn
}
import {fn,age,name} from &quot;./test.js&quot;;
//如果想要全部引入
import * as info from&#39;...&#39;
//通过*来批量接收，as 来指定接收的名字
console.log(info.fn());//我是laowang！今年90岁了
console.log(info.age);//90
console.log(info.name);//laowang
//一个模块只能有一个默认导出，对于默认导出，导入的名称可以和导出的名称不一致。
export default function(){
    return &quot;默认导出一个方法&quot;
}
import myFn from &quot;./test.js&quot;;//注意这里默认导出不需要用{}。
console.log(myFn());//默认导出一个方法
//可以将所有需要导出的变量放入一个对象中，然后通过default export进行导出
export default {
    myFn(){
        return &quot;默认导出一个方法&quot;
    },
    myName:&quot;laowang&quot;
}
import myObj from &quot;./test.js&quot;;
console.log(myObj.myFn(),myObj.myName);//默认导出一个方法 laowang
//重命名export和import
/******************************test1.js**********************/
export let myName=&quot;我来自test1.js&quot;;
/******************************test2.js**********************/
export let myName=&quot;我来自test2.js&quot;;
/******************************index.js**********************/
import {myName as name1} from &quot;./test1.js&quot;;
import {myName as name2} from &quot;./test2.js&quot;;
console.log(name1);//我来自test1.js
console.log(name2);//我来自test1.js</code></pre>
  </article>
  
    
<div class="nexmoe-post-copyright">
<i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
<strong>Author：</strong>shuo<br>
<strong>Link：</strong><a href="http://yoursite.com/2019/10/14/20191012-es6语法/" title="http://yoursite.com/2019/10/14/20191012-es6语法/" target="_blank" rel="noopener">http://yoursite.com/2019/10/14/20191012-es6语法/</a><br>

  <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

</div>


  
  <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="../../../../js/app.js?v=1571994655098"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>

  





</body>

</html>
